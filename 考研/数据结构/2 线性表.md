## 2.2 线性表的顺序表示 -- 顺序表

属于顺序储存结构。

**位序**：线性表中元素的位序是从1开始，下标从0开始

#### C++实现

```c++
#include <string>
using namespace std;

#define MaxSize 50
typedef struct {                   // 静态分配
	ElemType data[MaxSize];
	int length;
}SqList;

#define InitSize 100
typedef struct {
	ElemType *data;
	int Maxsize, length;           // 最大容量 当前个数
}SeqList;

```

可以通过动态分配在运行时决定表的长度，但表的最大长度是固定的，并不是链式储存。

```c++
L.data = new ElemType[InitSize];
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize);
```

#### 操作的时间复杂度

|                      | 最好 | 最坏 |    平均    |
| :------------------: | :--: | :--: | :--------: |
|         插入         | O(1) | O(n) |    O(n)    |
|         删除         | O(1) | O(n) |    O(n)    |
| 按值查找（顺序查找） | O(1) | O(n) |    O(n)    |
|       折半查找       |      |      | O(log~2~n) |

顺序表最主要的特点是==随机访问==，即通过首地址和元素序号可以在时间**O(1)**内找到指定的元素。

## 2.3 线性表的链式表示 -- 链表

### 单链表

```c++
typedef struct LNode {
	ElemType data;
	struct LNode* next;
}LNode, *LinkList;
```

**头结点**

链表第一个位置上的操作和其他位置上一致，空表和非空表的处理一致。

#### 常用算法

头插法：顺序相反 `LinkList listHeadInsert(LinkList &L);  `

尾插法：需要增加尾指针

按序号查找：`LNode *GetElem(LinkList L, int i);`

按值查找：`LNode *LocateElem(LinkList L, ElemType e);`

后插法：找到前驱节点，常用，表尾单独处理

```
p = GetElem(L,i-1);
s->next = p->next;
p->next = s;
```

前插法：转化为后插或后插法后交换两结点的值

```
s->next = p->next;
p->next = s;
temp = p->data;
p->data = s->data;
s->data = temp;
```

按序号删除：==表尾？==

```
p = GetElem(L,i-1);
q = p->next;
p->next = q->next;
free(q);
```

按值删除：找到前驱节点或用后继结点覆盖，然后删除后继结点

```
q = p->next;
p->data = q->data;
p->next = q->next;
free(q);
```

求表长：没有头结点时要单独处理空表情况

**以上所有算法的复杂度都是O(n)**

### 双链表

```C++
typedef struct DNode {
	ElemType data;
	struct DNode *next, *prior;
}DNode, *DLinkList;
```

插入、删除操作要保证不断链。

### 循环单链表

表中最后一个结点指向**头结点**，为空时头结点指向头结点

不设头指针而设尾指针，对表头和表尾操作都只需要O(1)

插入、删除操作无需判断是否是表尾

### 循环双链表

头结点的前驱指向尾结点，为空时头结点的两个指针都指向自己

### 静态链表

```c++
#define Maxsize 50
typedef struct {
	ElemType data;
	int next;          // 游标 -1作为结束标志
} SLinkList[Maxsize];
```

适用于不支持指针的高级语言（Basic）

## 2.4 顺序表&链表的比较与选择