## 3.1 栈（Stack）

后进先出 LIFO -- Last In First Out

==n个不同元素进栈，出栈元素不同排列个数为 $C{n \atop 2n}/(n+1)$==

##### 栈的基本操作

```c++
InitStack(&S)
StackEmpty(S)
Push(&S,x)        // 指针+1，入栈
Pop(&S,&x)        // 出栈，指针-1
GetTop(S,&x)
DestoryStack(&S)  // 销毁栈并释放存储空间
```

### 栈的顺序存储结构  --  顺序栈

```c++
#define MaxSize 50  // 可能发生栈上溢
typedef struct{
	ElemType data[MaxSize];
	int top;       // 栈顶指针 -1为空 栈长：S.top+1
} SqStack;
```

指针有两种情况：指向栈顶元素 或指向栈顶元素的下一位置（栈顶+1），对应的入栈出栈操作也不同

#### 共享栈

栈空：top0 = -1  top2 = MaxSize

栈满：top1 - top0 = 1

更有效的利用存储空间，两个栈的空间相互调节，只有整个存储空间被占满才发生上溢，存取数据的时间复杂度仍为O(1)

### 栈的链式存储结构  --  链栈

便于多个栈共享存储空间 提高效率

采用（不带头结点的）单链表实现，所有操作都在表头进行

```
typedef struct Linknode{
	ElemType data;
	struct Linknode *next;
} *LiStack;
```

## 3.2 队列（Queue）

先进先出 FIFO -- First In First Out

##### 基本操作

```
InitQueue(&Q)
QueueEmpty(Q)
EnQueue(&Q,x)
DeQueue(&Q,&x)
GetHead(Q,&x)
```

### 队列的顺序存储结构

```c++
#define MaxSize 50 
typedef struct{
	ElemType data[MaxSize];
	int front,rear;
} SqQueue;
```

假溢出

#### 循环队列

通过模运算实现循环

```c++
Q.front = Q.rear = 0  // 初始条件
(Q.rear + 1)%MaxSize == Q.front  // 队满
Q.front = Q.rear // 队空
Q.front = (Q.front + 1) % MaxSize  // 队首进1，出栈
Q.rear = (Q.rear + 1) % MaxSize  // 队尾进1，入栈
(Q.rear - Q.front + MaxSize) % MaxSize // 队列长度
```

### 队列的链式存储结构 -- 链队列

同时带有队头指针和队尾指针的单链表

```c++
typedef struct{
	ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{
    LinkNode *front, *rear;
}LinkQueue;
```

将链式队列设计为带头结点的单链表，以统一删除和插入操作

```
Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
Q.front->next = NULL;
Q.front == Q.rear;  // 队空
s->data
```

