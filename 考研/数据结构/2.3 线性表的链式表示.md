## 链表

### 单链表

```c++
typedef struct LNode {
	ElemType data;
	struct LNode* next;
}LNode, *LinkList;
```

**头结点**

链表第一个位置上的操作和其他位置上一致，空表和非空表的处理一致。

#### 常用算法

头插法：顺序相反 `LinkList listHeadInsert(LinkList &L);  `

尾插法：需要增加尾指针

按序号查找：`LNode *GetElem(LinkList L, int i);`

按值查找：`LNode *LocateElem(LinkList L, ElemType e);`

后插法：找到前驱节点，常用，表尾单独处理

```
p = GetElem(L,i-1);
s->next = p->next;
p->next = s;
```

前插法：转化为后插或后插法后交换两结点的值

```
s->next = p->next;
p->next = s;
temp = p->data;
p->data = s->data;
s->data = temp;
```

按序号删除：==表尾？==

```
p = GetElem(L,i-1);
q = p->next;
p->next = q->next;
free(q);
```

按值删除：找到前驱节点或用后继结点覆盖，然后删除后继结点

```
q = p->next;
p->data = q->data;
p->next = q->next;
free(q);
```

求表长：没有头结点时要单独处理空表情况

**以上所有算法的复杂度都是O(n)**

### 双链表

```C++
typedef struct DNode {
	ElemType data;
	struct DNode *next, *prior;
}DNode, *DLinkList;
```

插入、删除操作要保证不断链。

### 循环单链表

表中最后一个结点指向**头结点**，为空时头结点指向头结点

不设头指针而设尾指针，对表头和表尾操作都只需要O(1)

插入、删除操作无需判断是否是表尾

### 循环双链表

头结点的前驱指向尾结点，为空时头结点的两个指针都指向自己

### 静态链表

```c++
#define Maxsize 50
typedef struct {
	ElemType data;
	int next;          // 游标 -1作为结束标志
} SLinkList[Maxsize];
```

适用于不支持指针的高级语言（Basic）

## 顺序表&链表的比较与选择