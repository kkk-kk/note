## 时间复杂度的计算

### 对数阶时间复杂度

```
i=1;
while (i <= n)  {
     i = i * 2;
}
```

**分析循环**：i 从1==开始==，==每次循环==乘2，大于n时循环==结束==

**列式&求解**：2^k^ <= n ，即 n >= log~2~k

所以算法复杂度是 O(log~2~n)

可以忽略系数，即可以忽略对数的底，**统一表示为 ==O(logn)==**

**循环执行一段复杂度为O(logn)的算法的复杂度为 **==O(nlogn)==

## 双重循环时间复杂度

```c
for(i=n-1;i>1;i--)
	for(j=1;j<i;j++)
        if(A[j]>A[j+i])
            A[j]<->A[j+1];
```

冒泡排序，最差的情况下的时间复杂度

**分析循环**：n-1 + n-2 + n-3 + ... + 2 = (n + 1) * n / 2

```C
for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
        for(k=1;k<=j;k++)
            x++;
```

O($\sum_1^n$$\sum_1^i$$\sum_1^j$1) = O(n^3^/6) = O(n^3^)

内层循环 * 外层循环

###### 相关公式

1×2/2+2×3/2+3×4/2+……+n(n+1)/2 = n(n+1)(n+2)/6

1^2^+2^2^+3^2^+……+n^2^ = n(n+1)(2n+1)/6  

1^3^+2^3^+3^3^+……+n^3^ = [n(n+1)/2]^2^  

等比数列求和公式 Sn=a~1~(q^n^-1)/(q-1) （q != 1） 

等差数列求和公式 Sn=n*a~1~+n(n-1)d/2

## 复杂度举例

|    数据结构    |  连接  |  查找  |  插入  |  删除  |
| :------------: | :----: | :----: | :----: | :----: |
|    **数组**    |   1    |   n    |   n    |   n    |
|     **栈**     |   n    |   n    |   1    |   1    |
|    **队列**    |   n    |   n    |   1    |   1    |
|    **链表**    |   n    |   n    |   1    |   1    |
|   **哈希表**   |   -    |   n    |   n    |   n    |
| **二分查找树** |   n    |   n    |   n    |   n    |
|    **B树**     | log(n) | log(n) | log(n) | log(n) |
|   **红黑树**   | log(n) | log(n) | log(n) | log(n) |
|   **AVL树**    | log(n) | log(n) | log(n) | log(n) |

|     名称     |   最优   |      平均      |     最坏     |  内存  | 稳定 |
| :----------: | :------: | :------------: | :----------: | :----: | :--: |
| **冒泡排序** |    n     |      n^2       |     n^2      |   1    | Yes  |
| **插入排序** |    n     |      n^2       |     n^2      |   1    | Yes  |
| **选择排序** |   n^2    |      n^2       |     n^2      |   1    |  No  |
|  **堆排序**  | n log(n) |    n log(n)    |   n log(n)   |   1    |  No  |
| **归并排序** | n log(n) |    n log(n)    |   n log(n)   |   n    | Yes  |
| **快速排序** | n log(n) |    n log(n)    |     n^2      | log(n) |  No  |
| **希尔排序** | n log(n) | 取决于差距序列 | n (log(n))^2 |   1    |  No  |

## 题目

1、已知两个长度分别为m 和 n 的升序链表，若将它们合并为一个长度为 m+n 的降序链表，则最坏情况下的时间复杂度是（ ）。

A  O(n)

B  O(mn)

C  O(min(m ,n))

D  O(max(m,n))

`依次对链表中的首元素进行比较，取较小的一个插入新的链表，即每比较一次，确定一个元素。最坏情况是两个链表中的元素依次进行比较，2max(m,n) <= m+n,所以选D`

2、以下算法中最后一行的语句的执行次数为

```c
int m = 0,i,j;
for(i=1;i<=n;i++)
    for(j=1;j<=2*i;j++)
        m++;
```

`分析循环：2+4+6+8+...+2*n = 2*n + n*(n-1) = n(n+1)`

