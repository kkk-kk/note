# 划分数问题

## 题目描述

把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。

## 输入描述:

```
每行均包含二个整数M和N，以空格分开。1<=M，N<=10。
```

## 输出描述:

```
对输入的每组数据M和N，用一行输出相应的K。
```

## 分析

+ `dp[i][j]`表示将i划分到不超过j组中的划分数，即求`dp[M][N]`

+ 递推方程：`dp[i][j] = dp[i][j-1] + dp[i-j][j]`
  + 分为有空盘子和没有空盘子：
  + 有空盘子：`dp[i][j] = dp[i][j-1]`，有一个空盘子，有两个空盘子的情况包含在有一个空盘子的情况里(？
  + 没有空盘子：`dp[i][j] = dp[i-j][j]`  

+ 边界条件：
  + `M = 1` 时，`dp[1][n] = 1`
  + `N = 1`时，`dp[m][1] = 1`
+ 其他：
  + M = N时，`dp[n][n] = dp[n][n-1] + 1`
  + M < N时，盘子比苹果多，`dp[m][n] = dp[m][m]`
+ 总结：
  + `dp[i][j] = dp[i][j-1] + dp[i-j][j] (i > j)` 
  + `dp[i][j] = dp[i][i-1] + 1`

## 解答

```c++
#include <iostream>
using namespace std;

int M, N;

// 状态转移方程

int main() {
	int i, j, cnt;
	while (cin >> M >> N) {  // M - 苹果 N - 盘子
		M++;
		N++;
		int **dp = new int* [M];
		// 初始化
		for (i = 0;i < M;i++) {
			dp[i] = new int[N];
			dp[i][1] = 1;
		}
		for (i = 0;i < N;i++) {
			dp[1][i] = 1;
		}
		for (j = 2;j < N;j++) {
			for (i = 2;i < M;i++) {
				if (i > j) dp[i][j] = dp[i][j - 1] + dp[i - j][j];
				else dp[i][j] = dp[i][i - 1] + 1;
			}
		}
		cout << dp[M - 1][N - 1] << endl;

	}
}
```

