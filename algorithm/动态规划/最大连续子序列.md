# [最大连续子序列](https://www.nowcoder.com/practice/afe7c043f0644f60af98a0fba61af8e7?tpId=40&tqId=21472&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking&tab=answerKey)

## 题目描述

  给定K个整数的序列{ N1, N2, ..., NK }，其任意连续子序列可表示为{ Ni, Ni+1, ..., Nj }，其中 1 <= i <= j <= K。最大连续子序列是所有连续子序列中元素和最大的一个，例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。现在增加一个要求，即还需要输出该子序列的第一个和最后一个元素。

## 输入描述:

```
    测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( K< 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。
```

## 输出描述:

```
    对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。
```

## 分析

+ `dp[i]`表示以`A[i]`**作为末尾**的连续序列的最大和，即求dp[]的最大值
+ `A[i]`必须是末尾，则分为两种情况：
  + 子序列只有一个元素，即`A[i]`
  + 子序列有多个元素，则最大和是`dp[i-1] + A[i]`
+ 状态转移方程：`dp[i] = max{A[i],dp[i-1] + A[i]}`

## 解答

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

typedef struct Node {
	int sum;
	int begin, end;
	Node(int s, int b, int e) :sum(s), begin(b), end(e) {}
}Node;

bool cmp(Node a, Node b) {
	if (a.sum == b.sum) {
		if (a.begin == b.begin) {
			return a.end < b.end;
		}
		return a.begin < b.begin;
	}
	else return a.sum > b.sum;
}

int main() {
	int K;
	while (cin >> K && K != 0) {
		int *A = new int[K];
		for (int i = 0;i < K;i++)
			cin >> A[i];
		int begin, end;
		vector<Node> dp;
		dp.push_back(Node(A[0], 0, 0));
		int s;
		for (int i = 1;i < K;i++) {
			s = A[i] + dp[i-1].sum;
			if (s < A[i])
				dp.push_back(Node(A[i], i, i));
			else // 必须以i结尾，包括的dp[i-1] = 0情况
				dp.push_back(Node(s, dp[i - 1].begin, i));
		}
		sort(dp.begin(), dp.end(), cmp);
		cout << dp[0].sum << ' ' << A[dp[0].begin] << ' ' << A[dp[0].end] << endl;
		delete A;
		dp.clear();
	}
}
```

