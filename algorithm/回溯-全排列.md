# [全排列](https://leetcode-cn.com/problems/permutations)

## 题目

给定一个 没有重复 数字的序列，返回其所有可能的全排列。

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

## 回溯法

![image.png](image/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png)

与深度优先搜索相似，区别在于需要回溯，即访问完下一个节点后需要回退到原始状态再返回上一节点

## 解答

```c++
#include <iostream>
#include <vector>
using namespace std;

// 传递result时需要使用‘&’
void setPos(vector<int> one, vector<int>& nums, bool *flag, vector<vector<int>>& result, int pos) {
	if (pos == nums.size()) {
		vector<int> add = vector<int>(one);  // 复制构造方法
		result.push_back(add);
		return;
	}
	for (int i = 0; i < nums.size(); i++) {
		if (flag[i]) continue;
		one.push_back(nums.at(i));
		flag[i] = true;
		setPos(one, nums, flag, result, pos + 1);
		flag[i] = false;
		one.pop_back();
	}
}
vector<vector<int>> permute(vector<int>& nums) {
	vector<vector<int>> result;  // 保存排列结果
	vector<int> one;  // 正在生成的一种排列
	int length = nums.size(),i;
	bool *flag = new bool[length];
	for (int i = 0;i < length;i++) {
		flag[i] = false;
	}

	setPos(one, nums, flag, result, 0);
	return result;
}

int main() {
	vector<int> nums;
	int n;
	do {                         // 连续输入不定量的数字 以‘数字+回车’作为结尾
		cin >> n;                // 
		nums.push_back(n);       //
	} while (getchar() != '\n'); // 
	vector<vector<int>> result = permute(nums);
	for (vector<int> one : result) {
		cout << "[ ";
		for (int i : one) {
			cout << i << ' ';
		}
		cout << ']' << endl;
	}
}
```





## 非字典序

使用递归

```c++
#include <iostream>
#include <string>
using namespace std;

string str;
void perm(int begin, int end);
int main() {
	while (cin >> str) {
		perm(0, str.size());
	}
}

void perm(int begin, int end) {
	if (begin == end) {
		cout << str << endl;
		return;
	}
	char temp;
	for (int i = begin;i < end;i++) {
		temp = str[begin];
		str[begin] = str[i];
		str[i] = temp;
		perm(begin + 1, end);
		temp = str[begin];
		str[begin] = str[i];
		str[i] = temp;
	}
}
```

## 全排列

```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
	string str;
	while (cin >> str) {
		sort(str);  // 保证是最小的字典序
		do cout << str << endl;
		while (next_permutation(str.begin(), str.end()));
		cout << endl;
	}
}
```

