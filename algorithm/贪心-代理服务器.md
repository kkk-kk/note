# 代理服务器

## 题目描述

  使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。

## 输入描述:

```
    每个测试数据包括 n + m + 2 行。
    第 1 行只包含一个整数 n，表示代理服务器的个数。
    第 2行至第n + 1行每行是一个字符串，表示代理服务器的 IP地址。这n个 IP地址两两不相同。
    第 n + 2 行只包含一个整数 m，表示要访问的服务器的个数。
    第 n + 3 行至第 n + m + 2 行每行是一个字符串，表示要访问的服务器的 IP 地址，按照访问的顺序给出。
    每个字符串都是合法的IP地址，形式为“xxx.yyy.zzz.www”，其中任何一部分均是0–255之间的整数。输入数据的任何一行都不包含空格字符。
     其中，1<=n<=1000，1<=m<=5000。
```

## 输出描述:

```
    可能有多组测试数据，对于每组输入数据， 输出数据只有一行，包含一个整数s，表示按照要求访问服务器的过程中切换代理服务器的最少次数。第一次使用的代理服务器不计入切换次数中。若没有符合要求的安排方式，则输出-1
```

## 解答

##### 思路 -- 采用贪心策略

1. 找到能用的最久的代理ip

   用代理ip匹配服务器，选择匹配的最远的那个

2. 如果没有匹配，说明存在一个代理ip可以**剩下**访问所有，输出count

3. count+1，从当前位置开始下一轮匹配

```c++
#include <iostream>
#include <vector>
#include <string>
#include <vector>
using namespace std;

int N, M; // 代理服务器个数,要访问的服务器的个数
vector<string> proxy,server;

int match(string str, int beginPos) {  // **** 没有匹配时应该返回M ****
	for (int i = beginPos;i < M;i++) {
		if (str == server[i]) return i;
	}
	return M;
}

int main() {
	while (cin >> N) {
		string str;
		for (int i = 0;i < N;i++) {
			cin >> str;
			proxy.push_back(str);
		}
		cin >> M;
		for (int i = 0;i < M;i++) {
			string str;
			cin >> str;
			server.push_back(str);
		}
		int cnt = 0, beginPos = 0; // 切换次数,开始位置
		int matchPos = -1, choose = -1;
		while (true) {
			// 找到proxy[choose]：匹配的位置最远
			matchPos = -1, choose = -1;
			for (int i = 0;i < N;i++) {
				int j = match(proxy[i],beginPos);
				if (matchPos < j) {
					choose = i;
					matchPos = j;
					if (matchPos == M) break;
				}
			}
			if (choose != -1) { // 找到了
				if (beginPos == matchPos) {
					cout << -1 << endl;
					break;
				}
				beginPos = matchPos; // 开始位置设置为匹配到的
				if (beginPos == M) { // 剩下的都可以访问，可以退出
					cout << cnt << endl;
					break;
				}
				cnt++;
				continue;
			}
			else { // 没有找到，可以使用某代理ip访问剩下的部分
				cout << cnt << endl;
				break;
			}
		}
		server.clear();
		proxy.clear();
	}
}
```

