# 并查集

## 定义

```c++
// 并查集
int *father;
int N; // 长度 （可省略？）
```

## 基本操作

##### 初始化

```c++
void InitDSU() {
	for (int i = 0;i < N;i++) father[i] = i;
}
```

##### 查找

```c++
int FindFather(int x) {
	int a = x,z;
	while (x != father[x]) {
		x = father[x];
	}
	// 路径压缩
    // x此时存放根节点。下面把路径上的所有节点的father都改成根节点
	while (a != father[a]) {
		z = a;
		a = father[a]; // 回溯父亲节点
		father[z] = a; // 将原结点a的父亲改为根节点x
	}
	return x;
}
```

##### 合并

```c++
void Union(int a, int b) {
	int ra = FindFather(a), rb = FindFather(b);
	if (ra != rb) {
		father[rb] = ra;
	}
}
```

## [例题](https://www.nowcoder.com/practice/4878e6c6a24e443aac5211d194cf3913?tpId=40&tqId=21457&rp=1&ru=%2Fta%2Fkaoyan&qru=%2Fta%2Fkaoyan%2Fquestion-ranking&tab=answerKey)

某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？

```c++
#include <iostream>
using namespace std;

// 并查集
int *father;
int N; // 长度

void InitDSU() {
	for (int i = 0;i < N;i++) {
		father[i] = i;
	}
}

int FindFather(int x) {
	int a = x,z;
	while (x != father[x]) {
		x = father[x];
	}
	// 路径压缩
	while (a != father[a]) {
		z = a;
		a = father[a];
		father[z] = a;
	}
	return x;
}

void Union(int a, int b) {
	int ra = FindFather(a), rb = FindFather(b);
	if (ra != rb) {
		father[rb] = ra;
	}
}

int main() {
	int M; // N-结点 M-边
	while (cin >> N && N != 0) {
		cin >> M;
		father = new int[N];
		InitDSU();  // 初始化
		int b, e;
		for (int i = 0;i < M;i++) {
			cin >> b >> e;
			// 将b,e合并
			Union(b - 1, e - 1);
		}
		// 共有多少集合
		M = 0;
		for (int i = 0;i < N;i++) {
			if (father[i] == i) M++;
		}
		cout << M - 1 << endl;
		delete father;
		father = NULL;
	}
	return 0;
}
```

