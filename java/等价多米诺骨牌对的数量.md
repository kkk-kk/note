#### [ 等价多米诺骨牌对的数量](https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/)

给你一个由一些多米诺骨牌组成的列表 `dominoes`。

如果其中某一张多米诺骨牌可以通过旋转 `0` 度或 `180` 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。

形式上，`dominoes[i] = [a, b]` 和 `dominoes[j] = [c, d]` 等价的前提是 `a==c` 且 `b==d`，或是 `a==d` 且 `b==c`。

在 `0 <= i < j < dominoes.length` 的前提下，找出满足 `dominoes[i]` 和 `dominoes[j]` 等价的骨牌对 `(i, j)` 的数量。

**示例：**

```
输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]
输出：1
```

**提示：**

- `1 <= dominoes.length <= 40000`
- `1 <= dominoes[i][j] <= 9`

++++

```java
class Solution {
    public int numEquivDominoPairs(int[][] dominoes) {
        Integer count1,count2;
        int str1,str2;
        HashMap<Integer,Integer> hashMap = new HashMap<>(100); // 避免哈希表自动扩容

        for(int i=0;i<dominoes.length;i++){
            str1 = dominoes[i][0]*10 + dominoes[i][1];
            str2 = dominoes[i][1]*10 + dominoes[i][0];
            count1 = hashMap.get(str1);
            count2 = hashMap.get(str2);
            if(count1 == null && count2 == null) hashMap.put(str1, 1);
            else if(count1!=null) hashMap.put(str1, count1+1);
            else  hashMap.put(str2, count2 + 1);
        }
        int Sum = 0;
        for(Map.Entry<Integer,Integer> entry:hashMap.entrySet()){
            Sum += getNum(entry.getValue());  // 改成组合数公式反倒变大了
        }
        return Sum;
    }
    public int getNum(int n){
        if(n == 1) return 0;
        int sum = 0;
        for(int i=1;i<n;i++){
            sum += i;
        }
        return sum;
    }
}
```

++++

```java
import java.util.HashMap;
import java.util.Map;

public class Solution {
    public int numEquivDominoPairs(int[][] dominoes) {
        // 为了避免哈希表自动扩容，根据题目的数据范围，设置哈希表初始化的大小为 100
        // Pair 类重写了 hashCode() 和 equals() 方法
        Map<Pair, Integer> freq = new HashMap<>(100);
        for (int[] dominoe : dominoes) {
            Pair key = new Pair(dominoe[0], dominoe[1]);
            freq.put(key, freq.getOrDefault(key, 0) + 1);
        }
        // 根据组合数公式 C_n^2 = (n * (n - 1)) / 2 计算等价骨牌能够组成的组合数，再求和
        int count = 0;
        for (int f : freq.values()) {
            count += (f * (f - 1)) / 2;
        }
        return count;
    }

    private class Pair {

        private int key;
        private int value;

        public Pair(int key, int value) {
            this.key = key;
            this.value = value;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }
            Pair pair = (Pair) o;
            return key == pair.key && value == pair.value || key == pair.value && value == pair.key;
        }
        @Override
        public int hashCode() {
            if (key > value) {
                return value * 10 + key;
            }
            return key * 10 + value;
        }
    }
}
```

