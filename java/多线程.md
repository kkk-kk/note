# 线程

 在Java中，每次程序运行至少启动2个线程：一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程。

+++

### Java中线程实现的两种方式

+ 实现Runnable接口

  ```java
  class MyThread implements Runnable { // 实现Runnable接口
      private String name; // 线程名称
  
      public MyThread(String _name) {
          this.name = _name;
      }
  
      public void run() { // 覆写run()方法作为线程的操作主体
          for (int i = 0; i < 10; i++) {
              System.out.println(name + "run,i = " + i);
          }
      }
  
  }
  
  public class RunnableDemo1 {
      public static void main(String[] args) {
          MyThread myThread1 = new MyThread("Thread A ");  // 实例化对象
          MyThread myThread2 = new MyThread("Thread B ");
          Thread thread1 = new Thread(myThread1);  // 实例化Thread类对象
          Thread thread2 = new Thread(myThread2);
  
          thread1.start();  // 启动多线程
          thread2.start();
      }
  
  }
  ```

+ 集成Thread类

  ```java
  class My_Thread extends Thread {
      private String name;
  
      public My_Thread(String _name) {
          this.name = _name;
      }
  
      public void run() {
          for (int i = 0; i < 10; i++) {
              System.out.println(name + "run, i = " + i);
          }
      }
  }
  
  public class RunnableDemo1 {
      public static void main(String[] args) {
          My_Thread myThread1 = new My_Thread("Thread A ");
          My_Thread myThread2 = new My_Thread("Thread B ");
         
          myThread1.start();
          myThread2.start();
      }
  
  }
  ```

在线程启动虽然调用的是 start() 方法，但实际上调用的却是 run() 方法定义的主体。

Thread类的定义`public class Thread extends Object implements Runnable`

==从定义中可以发现，在 Thread 类中的 run() 方法调用的是 Runnable 接口中的 run() 方法，也就是说此方法是由 Runnable 子类完成的，所以如果要通过继承 Thread 类实现多线程，则必须覆写 run()。==

==实际上 Thread 类和 Runnable 接口之间在使用上也是有区别的，如果一个类继承 Thread类，则不适合于多个线程共享资源，而实现了 Runnable 接口，就可以方便的实现资源的共享。==

++++

### 线程的状态变化

+ 创建 `Thread thread=new Thread()`
+ 就绪 `start()`
+ 运行 `自动调用run()`
+ 阻塞 `sleep(),suspend(),wait() `
+ 死亡 `stop()`

### 线程的操作方法

+ 强制运行 `join()`

  ```
  class MyThread implements Runnable { // 实现Runnable接口
      public void run() { // 覆写run()方法作为线程的操作主体
          for (int i = 0; i < 10; i++) {
              System.out.println(Thread.currentThread().getName()+" run,i = "+i);
          }
      }
  
  }
  
  public class RunnableDemo1 {
      public static void main(String[] args) {
          MyThread myThread = new MyThread();
          Thread thread = new Thread(myThread);
          thread.start();
  
          for (int i = 0; i < 10; i++) {
              if (i > 5) {
                  try {
                      thread.join(); // 强制运行
                  } catch (InterruptedException e) {}
              }
              System.out.println("main run --> " + i);
          }
      }
  }
  ```

+ [中断线程](https://www.cnblogs.com/carmanloneliness/p/3516405.html) `interrupt()`

  ```java
  class MyThread implements Runnable { // 实现Runnable接口
      public void run() { // 覆写run()方法作为线程的操作主体
          System.out.println("1. get into run()");
          try {
              Thread.sleep(10000); // 休眠10秒
              System.out.println("2. finish sleep()");
          } catch (InterruptedException e) {
              System.out.println("3. interrupt sleep()");
              return; // 返回调用处
          }
  
          System.out.println("4. finish run()");
      }
  
  }
  
  public class RunnableDemo1 {
      public static void main(String[] args) {
          MyThread myThread = new MyThread();
          Thread thread = new Thread(myThread, "Thread*");
          thread.start();
  
          try {
              Thread.sleep(2000);
          } catch (InterruptedException e) {
              System.out.println("3. interrupt sleep()*");
          }
          thread.interrupt();
      }
  }
  ```

  ```
  输出：
  1. get into run()
  3. interrupt sleep()
  ```

+ 后台线程 `setDaemon()`

  ```
  class MyThread implements Runnable{ // 实现Runnable接口
      public void run(){  // 覆写run()方法
          while(true){
              System.out.println(Thread.currentThread().getName()+" is running");
          }
      }
  };
  public class ThreadDaemonDemo{
      public static void main(String args[]){
          MyThread mt = new MyThread() ;  // 实例化Runnable子类对象
          Thread t = new Thread(mt,"线程");     // 实例化Thread对象
          t.setDaemon(true) ; // 此线程在后台运行
          t.start() ; // 启动线程
      }
  };
  ```

+ 优先级 `setPriority(param)`

  + `Thread.MIN_PRIORITY`
  + `Thread.MAX_PRIORITY`
  + `Thread.NORM_PRIORITY`

+ 线程礼让 `yield()`

++++

### 同步、死锁

一个多线程的程序如果是通过 Runnable 接口实现的，则意味着类中的属性被多个线程共享，那么这样就会造成一种问题，如果这多个线程要操作同一个资源时就有可能出现资源同步问题。

#### 同步

+ 同步代码块

  ```
  synchronized(同步对象)｛ 
      需要同步的代码 
  ｝
  ```

  ```java
  class MyThread implements Runnable { // 实现Runnable接口
      private int ticket = 5;
  
      public void run() { // 覆写run()方法作为线程的操作主体
          for (int i = 0; i < 10; i++) {
              synchronized (this) {
                  if (ticket > 0) {
                      try {
                          Thread.sleep(300);  // bug?
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      System.out.println("SELL: ticket = " + ticket--);
                  }
              }
          }
      }
  }
  
  public class RunnableDemo1 {
      public static void main(String[] args) {
          MyThread myThread = new MyThread();
          Thread thread1 = new Thread(myThread);
          Thread thread2 = new Thread(myThread);
          Thread thread3 = new Thread(myThread);
          thread1.start();
          thread2.start();
          thread3.start();
      }
  }
  ```

+ 同步方法

  ```
  class MyThread implements Runnable{
      private int ticket = 5 ;    // 假设一共有5张票
      public void run(){
          for(int i=0;i<100;i++){
              this.sale() ;   // 调用同步方法
          }
      }
      public synchronized void sale(){    // 声明同步方法
          if(ticket>0){   // 还有票
              try{
                  Thread.sleep(300) ; // 加入延迟
              }catch(InterruptedException e){
                  e.printStackTrace() ;
              }
              System.out.println("卖票：ticket = " + ticket-- );
          }
  
      }
  };
  public class SyncDemo03{
      public static void main(String args[]){
          MyThread mt = new MyThread() ;  // 定义线程对象
          Thread t1 = new Thread(mt) ;    // 定义Thread对象
          Thread t2 = new Thread(mt) ;    // 定义Thread对象
          Thread t3 = new Thread(mt) ;    // 定义Thread对象
          t1.start() ;
          t2.start() ;
          t3.start() ;
      }
  };
  ```

#### 死锁



