#### 内容

J2EE导论，应用服务器（应用容器，GlassFish，JBoss），WEB容器，EJB容器，会话组件（表示逻辑层，有/无状态），跨容器注入机制。

#### 问题

###### 什么是J2EE容器？与EJB容器的关系是什么？试列举至少两种J2EE容器。

GlassFish、JBoss

###### 什么是无状态会话Bean？什么是有状态会话Bean? 什么是实体Bean？它们的区别是什么？

会话组件代表逻辑层，实体组件代表数据层

###### 什么是EJB的注入机制？

在web容器里面生成的jsp网页和服务器端小程序(?，跨容器的生成一个会话组件实例，就像本身的成员一样使用

###### 什么是SSSB的管理池？(pooling Sateless Session Beans)

在EJB容器里创建的无状态会话组件，在生命周期内，放在内存管理池（表格）里面，等待下一次来自客户端的请求，避免了重复创建

###### 什么是EJB的Java Persistence技术？

支撑通过实体组件对后台数据库的操作的技术。这种操作是实时的，原子的。java持久化技术

###### POJO plain old Java object

在通常的java类中加上一些标注，从而让EJB容器来完成一些工作，把普通的java对象升级成POJO对象。 

###### 试说明以下EJB Java标注的意义：@Remote, @Stateless, @Stateful, @Entity, @EJB, @Id, @Column, @PersistenceContext, @Table, @NamedQuery。



|        标注         |       意义       |
| :-----------------: | :--------------: |
|       @Remote       | 定义一个远程接口 |
|     @Stateless      |  无状态会话组件  |
|      @Stateful      |  有状态会话组件  |
|       @Entity       |      实体类      |
|        @EJB         |     注入体制     |
|         @Id         |                  |
|       @Column       |     字段、列     |
| @PresistenceContext |                  |
|       @Table        |       表单       |
|     @NameQuery      |                  |

## 第二章EJB 3.0

J2EE：基于组件的设计，开发，组装和部署企业应用程序的方法，是规范而不是产品

![image-20200317113357144](image-20200317113357144.png)

![ ](image-20200317113715284.png)

B/S & C/S

![image-20200317114057883](image-20200317114057883.png)

##### J2EE Techonologies

Web tier: Servlets and JSP
Enterprise tier: EJB
Data Access Layer: JDBC, JCA 
JMS
JTA
JavaMail
XML and Web Services: JAXP, JAX-RPC, JAXR
JNDI

##### Packaging Structure

![image-20200317114708513](image-20200317114708513.png)

##### Useful frameworks

Struts, Java Server Faces (JSF)

### Session Bean

本地/远程，有/无状态会话组件，如何访问会话组件

会话Bean代表客户端与企业应用程序的交互。 与在Web容器中运行的Servlet或JSP不同，会话Bean需要EJB容器。诸如Glassfish和JBOSS之类的企业应用服务器同时具有Web容器和EJB容器，EJB容器向其中部署的企业Java Bean提供安全性和事务管理之类的服务。虽然Servlet和JSP旨在通过Web浏览器进行访问，但是会话Bean通常旨在被其他程序或企业组件访问。 Servlet，其他企业Java Bean甚至桌面应用程序都可以访问它们。

会话Bean封装了业务方法，并提供了客户端代码的接口。 无需将业务逻辑添加到诸如Servlet之类的客户端组件，客户端代码仅需要调用会话bean的业务方法。这使客户端与应用程序业务逻辑的细节隔离开来，并允许不同类型的客户端访问同一应用程序，而无需重现或移植大量代码。它还使开发过程易于拆分。 Web设计人员可以专注于为应用程序创建Web客户端，而Java程序员可以专注于设置业务逻辑。

会话bean通常代表单个客户端与应用程序的交互，并在MVC设计模式中扮演控制器的角色。
这可能是针对简单应用程序的单个方法调用，也可能是会话中的多个相关调用（例如在线购物车）。为了适应客户端与应用程序交互的不同方式，会话bean有两种：有状态和无状态。

##### 本地和远程接口

​      除了无状态和有状态变量之外，会话Bean还可根据应用程序的要求定义为本地或远程。
​      这使Java企业应用程序可以根据需要进行扩展。 与驻留在特定服务器上特定上下文中的servlet不同，企业应用程序可以跨越位于不同物理位置的多个服务器。
​      可以从同一容器内访问本地bean。

​      远程会话Bean可以从远程源访问。
​      可以通过Java命名和目录接口（JNDI）访问远程会话bean，JNDI是EJB容器提供的目录服务。
​      远程bean也可以在本地访问，因此它们提供了很大的灵活性，如果应用程序需要可伸缩性，它们是一个不错的选择。
​      但是，灵活性要付出代价，因为所需的JNDI查找以及潜在的慢速网络访问会降低整体性能。

​      会话bean的界面可以使用@Remote或@Local批注定义远程或本地访问。
​      该接口是标准的Java接口，定义了客户端可用的方法。
​      通过实现业务接口，会话bean变得更加灵活。 只要接口保持不变，就可以根据需要进行修改。

##### 无状态会话组件

​      无状态会话Bean是不会在多个调用之间维护状态信息的会话Bean。 从Bean的角度来看，每次对会话Bean的业务方法的调用都来自不同的客户端。
​      不能保证为第一个应用程序请求提供服务的无状态会话Bean对象将与为将来的请求提供服务的实例相同。 这是因为EJB容器可以将无状态会话bean池化。
​      通过维护无状态会话Bean（SSB）池，EJB容器能够节省资源，因为它不必为每个客户端维护唯一的SSB实例。

​      无状态会话bean的生命周期非常简单。 它要么存在，要么不存在。 创建之后，它就存在于准备就绪并等待为客户端请求提供服务的无状态会话Bean池中。
​      服务请求后，将其放回池中，耐心等待另一个服务请求。

​      无状态会话Bean的优点是可以合并。 由于会话没有保存任何状态，因此无需将Bean的特定实例与特定客户端进行匹配。
​      如果后续调用由不同的实例提供服务，则客户端应用程序不知道（或不在乎）。
​      结果，会话Bean实例的总数可能小于访问应用程序的客户端总数，而不会影响性能。

###### Sample Session Bean Interface

```java
package com.datavikings.sessionbeans;
import javax.ejb.Remote;
@Remote
public interface HelloSessionRemote {
	String hiThere(String name);
}
```

###### Sample Stateless Session Bean Implementation

```java
package com.datavikings.sessionbeans;
import javax.ejb.Stateless;
@Stateless
public class HelloSessionBean implements HelloSessionRemote {
	public String hiThere(String name) {
		return "Hi there, " + name + "!";
	}
}
```

###### Sample Servlet Client:

```java
package com.datavikings.servlet;
import com.datavikings.sessionbeans.HelloSessionRemote;
import java.io.IOException;
import java.io.PrintWriter;
import javax.ejb.EJB;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloServlet extends HttpServlet {
	@EJB
	HelloSessionRemote greeter;
	protected void processRequest(HttpServletRequest request, 
				HttpServletResponse response) 
				throws ServletException, IOException {
		response.setContentType("text/html;charset=UTF-8");
       		PrintWriter out = response.getWriter();
		if(request.getParameter("name") != null) {
			out.println(greeter.hiThere(request.getParameter("name")) + "<br />");
		}
		out.println("<form method=\"post\" action=\"HelloServlet\">");
		out.println("Your name:<input type=\"text\" name=\"name\" />");
		out.println("<input type=\"submit\" value=\"Say Hi\" />");
		out.println("</form>");
       	out.close();
    } 
	protected void doGet(HttpServletRequest request, 
					HttpServletResponse response) 
			throws ServletException, IOException {
      	processRequest(request, response);
    } 
    protected void doPost(HttpServletRequest request, 
					HttpServletResponse response)
    			throws ServletException, IOException {
   		processRequest(request, response);
 		}
	}

```



### Entity Bean

