## Entity Bean

实体bean表示（持久）数据

每个应用程序都有数据

- 通常，这种数据自然地作为对象存在
- 应用程序需要一种将这些对象映射到其数据库的方法（通常是RDBMS）
  - 他们可以自己编写代码（例如JDBC）
  - 他们可以使用对象关系映射（ORM）框架

##### Object - Relational Mapping (ORM)  --  对象-关系映射

几种可用于java的ORM框架

- Hibernate (JBoss)
  - 作为NHibernate移植到.NET，使用称为Hibernate-QL的基于对象的查询语言
- TopLink (Oracle)
  - 使用表达式（expression）进行查询
- Object-relational Bridge -- OJB (Apache)
  - OJB是Apache免费提供的JDO的实现
- Java Data Objects -- JDO (Sun)
  - 可以在任何JVM中使用，使用称为JDO-QL的基于对象的查询语言
- Java Persistence (Sun) -- The ORM technology used by EJB
  - 目的是为持久性实体（即普通的Java对象– POJO）提供透明的框架。
  - Java Persistence使用称为EJB-QL的基于对象的查询语言（也称为Java Persistence查询语言）

RDBMS -- 关系数据库管理系统

---

##### Java Persistence Features

[Java Persistence API -- (JPA)](https://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html) provides a POJO persistence model for object-relational mapping

用Java持久性时，容器处理：==实体之间的关系 & 实体数据的持久性==。

==交易次数 & 安全== 是容器所有EJB的职责之外的

---

```java
import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class Customer {
	@Id public int customerID; // primary key
	public String firstName;
	public String lastName;
	… other fields omitted …
}
```

```java
import javax.persistence.*;

@Entity
@Table(name=“CustomerData”)
public class Customer {
	@Id
	@Column(name=“CustID”, primaryKey=true)
	public int customerID;

	@Column(name=“FName”)
	public String firstName;

	@Column(name=“LName”)
	public String lastName;
	… other fields omitted …
}
```

```java
import javax.persistence.*;

@Entity
@Table(name=“CustomerData”)
public class Customer {
	@Id
	@Column(name=“CustID”, primeyKey=true)
	public int getCustomerID() { … };
	public void setCustomerID(int value) { … };
	private int customerID;
	
	@Column(name=“FName”)
	public String getFirstName() { … };
	public void setFirstName(String value) { … };
	private String firstName;

	… other fields omitted …
}

```

---

### Entity Clients

从EJB 3.0开始，实体客户端通常是Session Bean

- 有时，开发人员为实体创建会话外观，这是一个会话Bean，其唯一目的是充当实体的CRUD（创建/读取/更新/销毁）

实体客户端的核心是EntityManager

- 该对象可用于获取，搜索，更新，创建和删除实体，可以将EntityManager注入会话外观

---

#### CRUDs -- create read update delete

目的是在实体上提供以下功能的对象，在Java EE中，CRUDs由**EntityManager**类实现。

- 创建–创建并保留实体的新实例

  + 实体几乎就是POJO，可以按常规方式创建，但在告知EntityManager持久化对象之前，不是持久的。

  ```java
  @PersistenceContext EntityManager entityManager;
  public Customer createCustomer(String fn, String ln) {
  	Customer customer = new Customer();
  	customer.setFirstName(fn);
  	customer.setLastName(ln);
  	// customer is not persistent here
  	entityManager.persist(customer);
  	// customer is persistent here
  	return customer;
  }
  ```

  

- 读取–查找单个实体（通过主键）并搜索实体组（查询）

  ```java
  // 通过主码找到特定实体 个体 individual
  @PersistenceContext EntityManager entityManager;
  public Customer getCustomer(int customerID) {
  	return entityManager.find(Customer.class, customerID);
  }
  ```

  ```java
  // search 查询语句
  @PersistenceContext EntityManager entityManager;
  public List<Customer> getAllCustomers() {
  	// this query is EJB-QL, which is similar to SQL
  	String queryString = “select c from Customer c”;
  	Query query = entityManager.createQuery(queryString);
  	return query.getResultList();
  }
  ```

  ```java
  // search 带参数查询
  @PersistenceContext EntityManager entityManager;
  public List<Customer> getCustomersWithLastName(String lastName) {
  	// this query is EJB-QL, which is similar to SQL
  	String queryString = “select c from Customer c where c.lastName = :lastName”;
  	Query query = entityManager.createQuery(queryString);
  	query.setParameter(“lastName”, lastName);
  	return query.getResultList();
  }
  ```

  ```java
  // search
  @PersistenceContext EntityManager entityManager;
  public List<Customer> getCustomersByNameKeyword(String keyword) {
  	// this query is EJB-QL, which is similar to SQL
  	String queryString = “select c from Customer c where c.lastName like :keyword1 or c.firstName like :keyword2”;
  	Query query = entityManager.createQuery(queryString);
  	query.setParameter(“keyword1”, keyword);
  	query.setParameter(“keyword2”, keyword);
  	return query.getResultList();
  }
  ```

  ```java
  // 可以在EJB本身中创建命名查询 Entity
  import javax.persistence.*;
  
  @Entity
  @Table(name=“CustomerData”)
  @NamedQueries({
  @NamedQuery(name="FindByCity",queryString=" select c from Customer c where c.city = ?1")
  }) 
  public class Customer {
  	@Id
  	@Column(name=“CustID”, primeyKey=true)
  	public int getCustomerID() { … };
  	… the remainder is no different from previous versions …
  // 可以从客户端引用命名查询，无需在此客户端中嵌入EJB-QL，这对于维护非常有用 search
  @PersistenceContext EntityManager entityManager;
  public List<Customer> getCustomersByCity(String city) {
  	Query query = entityManager.createNamedQuery(“FindByCity”);
  	query.setParameter(0, city);
  	return query.getResultList();
  }
  ```

- 更新–修改实体（在本地和持久存储中）

  - 实体持久化后，便成为托管对象，对受管实体的更改将自动记录到持久性存储中，更改将被缓存以提高效率，但是您可以flush()一个entityManager强制立即执行更改
  - 也可以使用refresh()方法将最新的数据库数据检索到实体中
  - `entityManager.fiush() // flush all update` 
  - `entityManager.refresh(cuatomer1) // update customer1`  

- 销毁–删除实体（本地和永久存储中）

  ```
  @PersistenceContext EntityManager entityManager;
  public void deleteCustomer(int customerID) {
  	Customer customer = manager.find(Customer.class, customerID);
  	manager.remove(customer);
  }
  ```

---

### Pooling Entities

一个实体容器（EJB容器）是实体对象的管理池（pool），类似于数据的缓存。

实体通过主键来提取。

如果该实体不存在，则创建一个新实例，填入正确数据

如果存在实体池，则不需要数据库访问，更快。

### Local Entities & Remote Entities

实体可以具有会话EJB之类的远程接口，但不好

实体类是细颗粒的，每种方法做的很少（变化比较小 例如传统的get set），网络开销小，不值得性能和网络成本

客户端请求会话组件接口，会话组件通过实体管理器对象来对实体对象进行操作，

会话组件（Session EJBs）是粗粒度的，每种方法都做的很多，性能和网络成本不是重要因素，后台实体对象代表数据库，频繁访问数据库，网络开销比较大

##### Session façades

提供粗粒度接口的会话组件，粗粒度接口只意味着会话组件方法会在实体上转变为多个本地调用。

两个客户端，会话组件通常与实体部署在同一服务器（对实体进行操作的客户端）上，会话组件客户端（Session EJB clients，e.g. JSPs）通常部署在另一服务器上并集群

Session façades = Entity Client

BMP & CMP

## JPQL

JPQL是EJB QL的扩展，比SQL更健壮，灵活和面向对象

持久化引擎（支撑软件）把查询语句转化为本地SQL

#### Creating Querie

Query instances 实例

+ EntityManager.createQuery  (dynamic query)
+ EntityManager.createNamedQuery (static query 静态查询)

Query API

+ getResultList() – execute query returning multiple results
+ getSingleResult() – execute query returning single result
+ executeUpdate() – execute bulk update or delete
+ setFirstResult() – set the first result to retrieve
+ setMaxResults() – set the maximum number of results to retrieve
+ setParameter() – bind a value to a named or positional parameter
+ setHint() – apply a vendor-specific hint to the query
+ setFlushMode()– apply a flush mode to the query when it gets run

#### Static(Named) Queries

@NamedQuery

- name -- the name of the query that will be used with the createNamedQuery method
- query -- query string

```java
@NamedQuery(name="findAllCustomers",query="SELECT c FROM Customer")
Query findAllQuery = entityManager.createNamedQuery(“findAllCustomers”); 
List customers = findAllQuery.getResultList();
```

#### Multiple Named Queries

@NamedQueries

```java
@NamedQueries( {
	@NamedQuery(name = “Mobile.selectAllQuery” 
		     query = “SELECT M FROM MOBILEENTITY”),
	@NamedQuery(name = “Mobile.deleteAllQuery” 
		     query = “DELETE M FROM MOBILEENTITY”)
} )
```

#### Named Parameters

命名参数是查询中以冒号(:)开头的参数，

设置参数值使用`Query.setParameter(String name, Object value)`

```java
public List findWithName(String name) {
	 return em.createQuery(
	 "SELECT c FROM Customer c WHERE c.name LIKE :custName")
		.setParameter("custName", name)
		.getResultList();
}
```

#### Positional Parameters

位置参数前面带有问号(?)，在查询中参数的数字位置后
设置参数值使用`Query.setParameter(integer position, Object value)`

```java
public List findWithName(String name) {
	return em.createQuery(
	“SELECT c FROM Customer c WHERE c.name LIKE ?1”)
	.setParameter(1, name)
	.getResultList();
}
```

#### Dynamic Queries

动态查询是直接在应用程序的业务逻辑中定义的查询

由于持久性引擎必须执行所有解析和验证工作，并且在运行时将JPQL映射到SQL，因此效率更低，查询执行速度更慢

```java
public List findAll(String entityName){
	return entityManager.createQuery(
      "select e from " + entityName + " e")
	.getResultList();
}
```

#### Native Queries

查询可以用本机SQL表示，支持需要使用目标数据库的本机SQL的情况

```java
Query q = em.createNativeQuery(
   "SELECT o.id, o.quantity, o.item " +
   "FROM Order o, Item i " +
   "WHERE (o.item = i.id) AND (i.name = 'widget')",
   com.acme.Order.class);
```

`com.acme.Order.class`

#### Query Operations -- Multiple Results

`Query.getResultList()`返回非参数化的List对象，只能在select语句上执行，否则`IllegalStateException`

```java
Query query = entityManager.createQuery(“SELECT C FROM CUSTOMER”);
List<MobileEntity> mobiles = (List<MobileEntity>)query.getResultList();
```

#### Query Operations -- Single Results

匹配失败，返回`EntityNotFoundException`，多个匹配，抛出运行时异常`NonUniqueResultException`

```java
Query singleSelectQuery = entityManager.createQuery(
“SELECT C FROM CUSTOMER WHERE C.ID = ‘ABC-123’”);
Customer custObj = singleSelectQuery.getSingleResult();
```

#### Query Operations -- Paging Query Results

```java
int maxRecords = 10; int startPosition = 0;
String queryString = “SELECT M FROM MOBILEENTITY”;
while(true){
	Query selectQuery = entityManager.createQuery(queryString);
	selectQuery.setMaxResults(maxRecords);
	selectQuery.setFirstResult(startPosition);
	List<MobileEntity> mobiles = 						entityManager.getResultList(queryString);
	if (mobiles.isEmpty()){ break; } 
	process(mobiles); 		// process the mobile entities
	entityManager.clear();	// detach the mobile objects
	startPosition = startPosition + mobiles.size();
}
```

#### Flushing Query Objects

- AUTO(default) -- 对实体对象所做的任何更改都会在下次执行SELECT查询时反映出来
- COMMIT -- 持久性引擎只能在数据库COMMIT期间更新实体的所有状态

#### JPQL Statement Language

JPQL statement types: SELECT, UPDATE, DELETE

Supported clauses:

- FROM
- WHERE
- GROUP_BY
- HAVING
- ORDER BY
- …

Conditional expressions, aggregate functions,…

#### JPQL Enhancements over EJBQL 2.x

- Simplified query syntax 
- JOIN operations 
- Group By and Having Clause 
- Subqueries 
- Dynamic queries 
- Named parameters 
- Bulk update and delete 

#### OO-style vs. SQL-style queries

查询应用程序模型，而不是数据库表